{"version":3,"file":"ktor-ktor-client-mock.js","sources":["collections/Collections.kt","util/Preconditions.kt","../../../../../common/src/kotlinx/io/core/Builder.kt","../../../../../ktor-client/ktor-client-mock/common/src/io/ktor/client/engine/mock/MockEngine.kt","../../../../../../../../../dummy.kt","util/Standard.kt","../../../../../ktor-client/ktor-client-mock/common/src/io/ktor/client/engine/mock/MockEngineConfig.kt","collections/MutableCollections.kt","../../../../../ktor-client/ktor-client-mock/common/src/io/ktor/client/engine/mock/MockUtils.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.pool.*\n\nexpect val PACKET_MAX_COPY_SIZE: Int\n\n/**\n * Build a byte packet in [block] lambda. Creates a temporary builder and releases it in case of failure\n */\ninline fun buildPacket(headerSizeHint: Int = 0, block: BytePacketBuilder.() -> Unit): ByteReadPacket {\n    val builder = BytePacketBuilder(headerSizeHint)\n    try {\n        block(builder)\n        return builder.build()\n    } catch (t: Throwable) {\n        builder.release()\n        throw t\n    }\n}\n\nexpect fun BytePacketBuilder(headerSizeHint: Int = 0): BytePacketBuilder\n\n/**\n * A builder that provides ability to build byte packets with no knowledge of it's size.\n * Unlike Java's ByteArrayOutputStream it doesn't copy the whole content every time it's internal buffer overflows\n * but chunks buffers instead. Packet building via [build] function is O(1) operation and only does instantiate\n * a new [ByteReadPacket]. Once a byte packet has been built via [build] function call, the builder could be\n * reused again. You also can discard all written bytes via [reset] or [release]. Please note that an instance of\n * builder need to be terminated either via [build] function invocation or via [release] call otherwise it will\n * cause byte buffer leak so that may have performance impact.\n *\n * Byte packet builder is also an [Appendable] so it does append UTF-8 characters to a packet\n *\n * ```\n * buildPacket {\n *     listOf(1,2,3).joinTo(this, separator = \",\")\n * }\n * ```\n */\nclass BytePacketBuilder(private var headerSizeHint: Int, pool: ObjectPool<IoBuffer>) :\n    @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderPlatformBase(pool) {\n    init {\n        require(headerSizeHint >= 0) { \"shouldn't be negative: headerSizeHint = $headerSizeHint\" }\n    }\n\n    /**\n     * Number of bytes written to the builder\n     */\n    val size: Int get() {\n        val size = _size\n        if (size == -1) {\n            _size = head.remainingAll().toInt()\n            return _size\n        }\n        return size\n    }\n\n    val isEmpty: Boolean get() {\n        val _size = _size\n        return when {\n            _size > 0 -> false\n            _size == 0 -> true\n            head.canRead() -> false\n            size == 0 -> true\n            else -> false\n        }\n    }\n\n    val isNotEmpty: Boolean get() {\n        val _size = _size\n        return when {\n            _size > 0 -> true\n            _size == 0 -> false\n            head.canRead() -> true\n            size > 0 -> true\n            else -> false\n        }\n    }\n\n    @PublishedApi\n    internal var head: IoBuffer = IoBuffer.Empty\n\n    override fun append(c: Char): BytePacketBuilder {\n        return super.append(c) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?): BytePacketBuilder {\n        return super.append(csq) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): BytePacketBuilder {\n        return super.append(csq, start, end) as BytePacketBuilder\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    override fun release() {\n        val head = this.head\n        val empty = IoBuffer.Empty\n\n        if (head !== empty) {\n            this.head = empty\n            this.tail = empty\n            head.releaseAll(pool)\n            _size = 0\n        }\n    }\n\n    override fun flush() {\n    }\n\n    override fun close() {\n        release()\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Suppress(\"OverridingDeprecatedMember\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun reset() {\n        release()\n    }\n\n    /**\n     * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n     * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n     * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n     * otherwise an unexpected behaviour may occur.\n     */\n    fun <R> preview(block: (tmp: ByteReadPacket) -> R): R {\n        val packet = preview()\n\n        return try {\n            block(packet)\n        } finally {\n            packet.release()\n        }\n    }\n\n    @PublishedApi\n    internal final fun preview(): ByteReadPacket {\n        val head = head\n        return when {\n            head === IoBuffer.Empty -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head.copyAll(), pool)\n        }\n    }\n\n    /**\n     * Builds byte packet instance and resets builder's state to be able to build another one packet if needed\n     */\n    fun build(): ByteReadPacket {\n        val size = size\n        val head = stealAll()\n\n        return when (head) {\n            null -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head, size.toLong(), pool)\n        }\n    }\n\n    /**\n     * Detach all chunks and cleanup all internal state so builder could be reusable again\n     * @return a chain of buffer views or `null` of it is empty\n     */\n    internal fun stealAll(): IoBuffer? {\n        val head = this.head\n        val empty = IoBuffer.Empty\n\n        this.head = empty\n        this.tail = empty\n        this._size = 0\n\n        return if (head === empty) null else head\n    }\n\n    internal fun afterBytesStolen() {\n        val head = head\n        check(head.next == null)\n        _size = 0\n        head.resetForWrite()\n        head.reserveStartGap(headerSizeHint)\n        head.reserveEndGap(IoBuffer.ReservedSize)\n    }\n\n    /**\n     * Writes another packet to the end. Please note that the instance [p] gets consumed so you don't need to release it\n     */\n    override fun writePacket(p: ByteReadPacket) {\n        val foreignStolen = p.stealAll()\n        if (foreignStolen == null) {\n            p.release()\n            return\n        }\n\n        val tail = tail\n        if (tail === IoBuffer.Empty) {\n            head = foreignStolen\n            this.tail = foreignStolen.findTail()\n            _size = foreignStolen.remainingAll().toInt()\n            return\n        }\n\n        writePacketSlow(tail, foreignStolen, p)\n    }\n\n    private fun writePacketSlow(tail: IoBuffer, foreignStolen: IoBuffer, p: ByteReadPacket) {\n        val lastSize = tail.readRemaining\n        val nextSize = foreignStolen.readRemaining\n\n        val maxCopySize = PACKET_MAX_COPY_SIZE\n        val appendSize = if (nextSize < maxCopySize && nextSize <= (tail.endGap + tail.writeRemaining)) {\n            nextSize\n        } else -1\n\n        val prependSize = if (lastSize < maxCopySize && lastSize <= foreignStolen.startGap && foreignStolen.isExclusivelyOwned()) {\n            lastSize\n        } else -1\n\n        if (appendSize == -1 && prependSize == -1) {\n            // simply enqueue\n            tail.next = foreignStolen\n            this.tail = foreignStolen.findTail()\n            _size = head.remainingAll().toInt()\n        } else if (prependSize == -1 || appendSize <= prependSize) {\n            // do append\n            tail.writeBufferAppend(foreignStolen, tail.writeRemaining + tail.endGap)\n            tail.next = foreignStolen.next\n            this.tail = foreignStolen.findTail().takeUnless { it === foreignStolen } ?: tail\n            foreignStolen.release(p.pool)\n            _size = head.remainingAll().toInt()\n        } else if (appendSize == -1 || prependSize < appendSize) {\n            writePacketSlowPrepend(foreignStolen, tail)\n        } else {\n            throw IllegalStateException(\"prep = $prependSize, app = $appendSize\")\n        }\n    }\n\n    private fun writePacketSlowPrepend(foreignStolen: IoBuffer, tail: IoBuffer) {\n        // do prepend\n        foreignStolen.writeBufferPrepend(tail)\n\n        if (head === tail) {\n            head = foreignStolen\n        } else {\n            var pre = head\n            while (true) {\n                val next = pre.next!!\n                if (next === tail) break\n                pre = next\n            }\n\n            pre.next = foreignStolen\n        }\n        tail.release(pool)\n\n        this.tail = foreignStolen.findTail()\n        _size = head.remainingAll().toInt()\n    }\n\n    override fun last(buffer: IoBuffer) {\n        if (head === IoBuffer.Empty) {\n            if (buffer.isEmpty()) { // headerSize is just a hint so we shouldn't force to reserve space\n                buffer.reserveStartGap(headerSizeHint) // it will always fail for non-empty buffer\n            }\n            tail = buffer\n            head = buffer\n            _size = buffer.remainingAll().toInt()\n        } else {\n            tail.next = buffer\n            tail = buffer\n            _size = -1\n        }\n    }\n}\n\n/**\n * Discard all written bytes and prepare to build another packet.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun BytePacketBuilder.reset() {\n    release()\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\nexpect abstract class BytePacketBuilderPlatformBase\ninternal constructor(pool: ObjectPool<IoBuffer>) : BytePacketBuilderBase\n\n/**\n * This is the default [Output] implementation\n */\n@ExperimentalIoApi\nabstract class AbstractOutput(pool: ObjectPool<IoBuffer> = IoBuffer.Pool) :\n    @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderPlatformBase(pool) {\n    @Deprecated(\"Will be removed. Override flush(buffer) properly.\", level = DeprecationLevel.ERROR)\n    protected var currentTail: IoBuffer\n        get() = this.tail\n        set(newValue) {\n            this.tail = newValue\n        }\n\n    /**\n     * An implementation should write the whole [buffer] to the destination. It should never capture the [buffer] instance\n     * longer than this method execution since it will be disposed after return.\n     * There is no need to follow [buffer]'s next chunk: this function is invoked for every chunk.\n     */\n    protected abstract fun flush(buffer: IoBuffer)\n\n    /**\n     * An implementation should only close the destination.\n     */\n    protected abstract fun closeDestination()\n\n    @Deprecated(\"This makes no sense for anything except BytePacketBuilder.\")\n    final override fun reset() {\n    }\n\n    /**\n     * Invoked when a new [buffer] is appended for writing (usually it's empty)\n     */\n    final override fun last(buffer: IoBuffer) {\n        var current = tail\n        tail = buffer\n\n        if (current === IoBuffer.Empty) return\n\n        do {\n            val next = current.next\n            current.next = null\n\n            try {\n                flush(current)\n            } catch (t: Throwable) {\n                next?.releaseAll(pool)\n                throw t\n            } finally {\n                current.release(pool)\n            }\n\n            if (next == null) break\n            current = next\n        } while (true)\n    }\n\n    final override fun release() {\n        val tail = tail\n        this.tail = IoBuffer.Empty\n        if (tail !== IoBuffer.Empty) {\n            tail.release(pool)\n        }\n        closeDestination()\n    }\n\n    final override fun flush() {\n        last(IoBuffer.Empty)\n    }\n\n    /**\n     * Should flush and close the destination\n     */\n    final override fun close() {\n        try {\n            flush()\n        } finally {\n            release()\n        }\n    }\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION\")\nabstract class BytePacketBuilderBase internal constructor(protected val pool: ObjectPool<IoBuffer>) : Appendable, Output {\n    @Deprecated(\n        \"Suppress warning.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    final override val doNotImplementOutputButExtendAbstractOutputInstead: Nothing\n        get() = error(\"Should be never accessed.\")\n\n    /**\n     * Number of bytes currently buffered or -1 if not known (need to be recomputed)\n     */\n    protected var _size: Int = 0\n\n    /**\n     * Byte order (Endianness) to be used by future write functions calls on this builder instance. Doesn't affect any\n     * previously written values. Note that [reset] doesn't change this value back to the default byte order.\n     * @default [ByteOrder.BIG_ENDIAN]\n     */\n    @Deprecated(\"Write with writeXXXLittleEndian or do X.reverseByteOrder() and then writeXXX instead.\")\n    final override var byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n        set(value) {\n            field = value\n            val tail = tail\n            if (tail.canWrite()) {\n                // it is important to not set byte order for IoBuffer.Empty as it will crash on native\n                tail.byteOrder = value\n            }\n        }\n\n    @PublishedApi\n    internal var tail: IoBuffer = IoBuffer.Empty\n\n    final override fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        if (length == 0) return\n\n        var copied = 0\n\n        writeLoop(1, { copied < length }) { buffer, bufferRemaining ->\n            val size = minOf(bufferRemaining, length - copied)\n            buffer.writeFully(src, offset + copied, size)\n            copied += size\n            size\n        }\n    }\n\n    final override fun writeLong(v: Long) {\n        write(8) { it.writeLong(v); 8 }\n    }\n\n    final override fun writeInt(v: Int) {\n        write(4) { it.writeInt(v); 4 }\n    }\n\n    final override fun writeShort(v: Short) {\n        write(2) { it.writeShort(v); 2 }\n    }\n\n    final override fun writeByte(v: Byte) {\n        write(1) { it.writeByte(v); 1 }\n    }\n\n    final override fun writeDouble(v: Double) {\n        write(8) { it.writeDouble(v); 8 }\n    }\n\n    final override fun writeFloat(v: Float) {\n        write(4) { it.writeFloat(v); 4 }\n    }\n\n    override fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        if (length == 0) return\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(2, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 1, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 2\n        }\n    }\n\n    override fun writeFully(src: IntArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(4, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 2, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 4\n        }\n    }\n\n    override fun writeFully(src: LongArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(8, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 3, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 8\n        }\n    }\n\n    override fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(4, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 2, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 4\n        }\n    }\n\n    override fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(8, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 3, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 8\n        }\n    }\n\n    override fun writeFully(src: IoBuffer, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(length <= src.readRemaining) { \"Not enough bytes available in src buffer to read $length bytes\" }\n\n        val totalSize = minOf(src.readRemaining, length)\n        if (totalSize == 0) return\n        var remaining = totalSize\n\n        var tail = tail\n        if (!tail.canWrite()) {\n            tail = appendNewBuffer()\n        }\n\n        do {\n            val size = minOf(tail.writeRemaining, remaining)\n            tail.writeFully(src, size)\n            remaining -= size\n\n            if (remaining == 0) break\n            tail = appendNewBuffer()\n        } while (true)\n\n        addSize(totalSize)\n    }\n\n    override fun fill(n: Long, v: Byte) {\n        require(n >= 0L) { \"n shouldn't be negative: $n\" }\n\n        var rem = n\n        writeLoop(1, { rem > 0L }) { buffer, chunkRemaining ->\n            val size = minOf(chunkRemaining.toLong(), n).toInt()\n            buffer.fill(size.toLong(), v)\n            rem -= size\n            size\n        }\n    }\n\n    /**\n     * Append single UTF-8 character\n     */\n    override fun append(c: Char): @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderBase {\n        write(3) {\n            it.putUtf8Char(c.toInt())\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?): @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderBase {\n        if (csq == null) {\n            appendChars(\"null\", 0, 4)\n        } else {\n            appendChars(csq, 0, csq.length)\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderBase {\n        if (csq == null) {\n            return append(\"null\", start, end)\n        }\n\n        appendChars(csq, start, end)\n\n        return this\n    }\n\n    open fun writePacket(p: ByteReadPacket) {\n        while (true) {\n            val buffer = p.steal() ?: break\n            last(buffer)\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    fun writePacket(p: ByteReadPacket, n: Int) {\n        var remaining = n\n\n        while (remaining > 0) {\n            val headRemaining = p.headRemaining\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                last(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining)\n                }\n                break\n            }\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    fun writePacket(p: ByteReadPacket, n: Long) {\n        var remaining = n\n\n        while (remaining > 0L) {\n            val headRemaining = p.headRemaining.toLong()\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                last(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining.toInt())\n                }\n                break\n            }\n        }\n    }\n\n    override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        appendChars(csq, start, end)\n        return this\n    }\n\n    private fun appendChars(csq: CharSequence, start: Int, end: Int): Int {\n        var idx = start\n        if (idx >= end) return idx\n        val tail = tail\n        if (tail.canWrite()) {\n            idx = tail.appendChars(csq, idx, end)\n        }\n\n        while (idx < end) {\n            idx = appendNewBuffer().appendChars(csq, idx, end)\n        }\n\n        this._size = -1\n        return idx\n    }\n\n    private fun appendChars(csq: CharArray, start: Int, end: Int): Int {\n        var idx = start\n        if (idx >= end) return idx\n        val tail = tail\n        if (tail.canWrite()) {\n            idx = tail.appendChars(csq, idx, end)\n        }\n\n        while (idx < end) {\n            idx = appendNewBuffer().appendChars(csq, idx, end)\n        }\n\n        this._size = -1\n        return idx\n    }\n\n    fun writeStringUtf8(s: String) {\n        append(s, 0, s.length)\n    }\n\n    fun writeStringUtf8(cs: CharSequence) {\n        append(cs, 0, cs.length)\n    }\n\n//    fun writeStringUtf8(cb: CharBuffer) {\n//        append(cb, 0, cb.remaining())\n//    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun IoBuffer.putUtf8Char(v: Int) = when {\n        v in 1..0x7f -> {\n            writeByte(v.toByte())\n            1\n        }\n        v > 0x7ff -> {\n            writeByte((0xe0 or ((v shr 12) and 0x0f)).toByte())\n            writeByte((0x80 or ((v shr  6) and 0x3f)).toByte())\n            writeByte((0x80 or ( v         and 0x3f)).toByte())\n            3\n        }\n        else -> {\n            writeByte((0xc0 or ((v shr  6) and 0x1f)).toByte())\n            writeByte((0x80 or ( v         and 0x3f)).toByte())\n            2\n        }\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    abstract fun release()\n\n    @DangerousInternalIoApi\n    fun prepareWriteHead(n: Int): IoBuffer {\n        if (tail.writeRemaining >= n) return tail\n        return appendNewBuffer()\n    }\n\n    @DangerousInternalIoApi\n    fun afterHeadWrite() {\n        _size = -1\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    open fun reset() {\n    }\n\n    @PublishedApi\n    internal inline fun write(size: Int, block: (IoBuffer) -> Int) {\n        var buffer = tail\n        if (buffer.writeRemaining < size) {\n            buffer = appendNewBuffer()\n        }\n\n        addSize(block(buffer))\n    }\n\n    private inline fun writeLoop(size: Int, predicate: () -> Boolean, block: (IoBuffer, Int) -> Int) {\n        if (!predicate()) return\n        var written = 0\n        var buffer = tail\n        var rem = buffer.writeRemaining\n\n        do {\n            if (rem < size) {\n                buffer = appendNewBuffer()\n                rem = buffer.writeRemaining\n            }\n\n            val result = block(buffer, rem)\n            written += result\n            rem -= result\n        } while (predicate())\n\n        addSize(written)\n    }\n\n    @PublishedApi\n    internal fun addSize(n: Int) {\n        val size = _size\n        if (size != -1) {\n            _size = size + n\n        }\n    }\n\n    internal abstract fun last(buffer: IoBuffer)\n\n    @PublishedApi\n    internal fun appendNewBuffer(): IoBuffer {\n        val new = pool.borrow()\n        new.reserveEndGap(IoBuffer.ReservedSize)\n        new.byteOrder = byteOrder\n\n        last(new)\n\n        return new\n    }\n}\n\nprivate inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    return if (!predicate(this)) this else null\n}\n\n\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.mock\n\nimport io.ktor.client.engine.*\nimport io.ktor.client.request.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * [HttpClientEngine] for writing tests without network.\n */\nclass MockEngine(\n    override val config: MockEngineConfig\n) : HttpClientEngine {\n    private var invocationCount = 0\n    private val _requestsHistory: MutableList<HttpRequestData> = mutableListOf()\n    private val _responseHistory: MutableList<HttpResponseData> = mutableListOf()\n    private val contextState: CompletableJob = Job()\n\n    init {\n        check(config.requestHandlers.size > 0) {\n            \"No request handler provided in [MockEngineConfig], please provide at least one.\"\n        }\n    }\n\n    /**\n     * History of executed requests.\n     */\n    val requestHistory: List<HttpRequestData> get() = _requestsHistory\n\n    /**\n     * History of sent responses.\n     */\n    val responseHistory: List<HttpResponseData> get() = _responseHistory\n\n    override val dispatcher: CoroutineDispatcher = Dispatchers.Unconfined\n\n    override val coroutineContext: CoroutineContext = dispatcher + contextState\n\n    override suspend fun execute(data: HttpRequestData): HttpResponseData {\n        if (invocationCount >= config.requestHandlers.size) error(\"Unhandled ${data.url}\")\n        val handler = config.requestHandlers[invocationCount]\n\n        invocationCount += 1\n        if (config.reuseHandlers) {\n            invocationCount %= config.requestHandlers.size\n        }\n\n\n        val response = handler(data)\n\n        _requestsHistory.add(data)\n        _responseHistory.add(response)\n\n        return response\n    }\n\n    @Suppress(\"KDocMissingDocumentation\")\n    override fun close() {\n        contextState.complete()\n    }\n\n    companion object : HttpClientEngineFactory<MockEngineConfig> {\n        override fun create(block: MockEngineConfig.() -> Unit): HttpClientEngine =\n            MockEngine(MockEngineConfig().apply(block))\n\n        /**\n         * Create [MockEngine] instance with single request handler.\n         */\n        operator fun invoke(handler: suspend (HttpRequestData) -> HttpResponseData): MockEngine =\n            MockEngine(MockEngineConfig().apply {\n                requestHandlers.add(handler)\n            })\n    }\n}\n",null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.mock\n\nimport io.ktor.client.call.*\nimport io.ktor.client.engine.*\nimport io.ktor.client.request.*\nimport io.ktor.client.response.*\n\n/**\n * Single [HttpClientCall] to [HttpResponse] mapper.\n */\ntypealias MockRequestHandler = suspend (request: HttpRequestData) -> HttpResponseData\n\n/**\n * [HttpClientEngineConfig] for [MockEngine].\n */\nclass MockEngineConfig : HttpClientEngineConfig() {\n\n    /**\n     * Request handlers.\n     * Responses are given back in order they were added to [requestHandlers].\n     */\n    val requestHandlers: MutableList<MockRequestHandler> = mutableListOf()\n\n    /**\n     * Should engine reuse handlers.\n     */\n    var reuseHandlers: Boolean = true\n\n    /**\n     * Add request handler to [MockEngine]\n     */\n    fun addHandler(handler: MockRequestHandler) {\n        requestHandlers += handler\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n/**\n * Randomly shuffles elements in this mutable list using the specified [random] instance as the source of randomness.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.mock\n\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport io.ktor.util.date.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.io.*\nimport kotlinx.io.charsets.*\nimport kotlinx.io.core.*\nimport kotlin.coroutines.*\n\n@Suppress(\"KDocMissingDocumentation\")\n@KtorExperimentalAPI\nsuspend fun OutgoingContent.toByteArray(): ByteArray = when (this) {\n    is OutgoingContent.ByteArrayContent -> bytes()\n    is OutgoingContent.ReadChannelContent -> readFrom().toByteArray()\n    is OutgoingContent.WriteChannelContent -> {\n        ByteChannel().also { writeTo(it) }.toByteArray()\n    }\n    else -> ByteArray(0)\n}\n\n@Suppress(\"KDocMissingDocumentation\")\n@KtorExperimentalAPI\nsuspend fun OutgoingContent.toByteReadPacket(): ByteReadPacket = when (this) {\n    is OutgoingContent.ByteArrayContent -> ByteReadPacket(bytes())\n    is OutgoingContent.ReadChannelContent -> readFrom().readRemaining()\n    is OutgoingContent.WriteChannelContent -> {\n        ByteChannel().also { writeTo(it) }.readRemaining()\n    }\n    else -> ByteReadPacket.Empty\n}\n\n/**\n * Send error response.\n */\nfun respondError(\n    status: HttpStatusCode,\n    content: String = status.description,\n    headers: Headers = headersOf()\n): HttpResponseData = respond(content, status, headers)\n\n/**\n * Send ok response.\n */\nfun respondOk(\n    content: String = \"\"\n): HttpResponseData = respond(content, HttpStatusCode.OK)\n\n\n/**\n * Send [HttpStatusCode.BadRequest] response.\n */\nfun respondBadRequest() = respond(\"Bad Request\", HttpStatusCode.BadRequest)\n\n/**\n * Send response with specified string [content], [status] and [headers].\n */\nfun respond(\n    content: String,\n    status: HttpStatusCode = HttpStatusCode.OK,\n    headers: Headers = headersOf()\n): HttpResponseData =\n    respond(ByteReadChannel(content.toByteArray(Charsets.UTF_8)), status, headers)\n\n/**\n * Send response with specified bytes [content], [status] and [headers].\n */\nfun respond(\n    content: ByteArray,\n    status: HttpStatusCode = HttpStatusCode.OK,\n    headers: Headers = headersOf()\n): HttpResponseData = respond(ByteReadChannel(content), status, headers)\n\n/**\n * Send response with specified [ByteReadChannel] [content], [status] and [headers].\n */\nfun respond(\n    content: ByteReadChannel,\n    status: HttpStatusCode = HttpStatusCode.OK,\n    headers: Headers = headersOf()\n): HttpResponseData = HttpResponseData(\n    status, GMTDate(), headers, HttpProtocolVersion.HTTP_1_1, content, createMockCallContext()\n)\n\nprivate fun createMockCallContext(): CoroutineContext = Dispatchers.Default + Job()\n"],"names":[],"mappings":"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"}